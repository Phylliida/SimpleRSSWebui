<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Simple RSS Feeds</title>
  <style>
    :root {
      --bg: #0f172a;
      --fg: #e2e8f0;
      --card: #1e293b;
      --accent: #7dd3fc;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: "Palatino", "Book Antiqua", serif;
      background: radial-gradient(circle at 20% 20%, rgba(125, 211, 252, 0.12), transparent 35%),
                  radial-gradient(circle at 80% 0%, rgba(248, 113, 113, 0.14), transparent 30%),
                  var(--bg);
      color: var(--fg);
      display: grid;
      place-items: center;
      padding: 2rem;
    }
    .card {
      width: min(720px, 100%);
      background: var(--card);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 14px;
      box-shadow: 0 16px 60px rgba(0, 0, 0, 0.35);
      padding: 24px 26px;
    }
    h1 {
      margin: 0 0 8px;
      letter-spacing: 0.02em;
      font-size: 28px;
    }
    p {
      margin: 0 0 16px;
      color: #cbd5e1;
    }
    form {
      display: flex;
      gap: 10px;
      margin: 0;
      flex-wrap: wrap;
    }
    input[type="url"],
    input[type="text"],
    select {
      flex: 1 1 260px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(15, 23, 42, 0.8);
      color: var(--fg);
      outline: none;
    }
    input[type="url"]:focus,
    input[type="text"]:focus,
    select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.3);
    }
    button {
      padding: 10px 16px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--accent), #38bdf8);
      color: #0f172a;
      font-weight: 700;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    button:hover { transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    a {
      color: var(--accent);
      text-decoration: none;
    }
    a:hover { text-decoration: underline; }
    .hidden { display: none; }
    .list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 8px;
    }
    .collapsible {
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.55);
      padding: 0;
      overflow: hidden;
    }
    .collapsible summary {
      list-style: none;
      cursor: pointer;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.02);
      font-weight: 700;
      letter-spacing: 0.01em;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .collapsible[open] summary {
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
    .collapsible summary::-webkit-details-marker { display: none; }
    .collapsible .collapsible-body {
      padding: 10px 12px 12px;
      display: grid;
      gap: 12px;
    }
    .collapsible .collapsible-body > * + * {
      margin-top: 10px;
    }
    .collapsible .list {
      padding: 10px 12px 12px;
    }
    .feeds-block {
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.55);
      overflow: hidden;
      margin-top: 4px;
    }
    .feeds-panel {
      padding: 10px 12px 12px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.01);
    }
    .feeds-panel .list { padding: 0; }
    .spoiler-btn {
      width: 100%;
      text-align: left;
      border: none;
      background: rgba(255, 255, 255, 0.02);
      color: var(--fg);
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .feeds-block.open .spoiler-btn {
      background: rgba(255, 255, 255, 0.04);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
    }
    .spoiler-arrow { transition: transform 120ms ease; display: inline-block; }
    .spoiler-btn[aria-expanded="true"] .spoiler-arrow { transform: rotate(180deg); }
    .list li {
      padding: 10px 12px;
      background: rgba(15, 23, 42, 0.7);
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.07);
      word-break: break-word;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .feed-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1 1 auto;
      min-width: 0;
    }
    .feed-url {
      color: #94a3b8;
      font-size: 13px;
    }
    .folder-label {
      color: #cbd5e1;
      font-size: 13px;
    }
    .list li.viewed {
      opacity: 0.75;
    }
    #items li {
      align-items: flex-start;
      flex-direction: column;
      gap: 6px;
    }
    .item-head {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      width: 100%;
    }
    .item-main {
      flex: 1 1 auto;
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .item-actions {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
    }
    .item-title {
      font-weight: 700;
      line-height: 1.3;
    }
    .item-title.with-avatar {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .item-title .item-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      flex: 0 0 auto;
    }
    .rt-icon {
      display: inline-flex;
      vertical-align: middle;
      color: #a5f3fc;
      line-height: 0;
      transform: translateY(3px) translateX(2px);
    }
    .rt-icon svg {
      width: 14px;
      height: 14px;
      display: block;
    }
    .meta {
      color: #cbd5e1;
      font-size: 14px;
    }
    .meta-avatar {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      object-fit: cover;
      vertical-align: middle;
    }
    .retweet-meta {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .summary {
      color: #e2e8f0;
      font-size: 15px;
      line-height: 1;
      white-space: pre-line;
    }
    .summary p {
      margin: 0;
    }
    .summary blockquote p {
      margin: 0;
    }
    br {
      display: block;
      margin: 0;
      line-height: 0;
      height: 0;
    }
    .thumb-wrap {
      flex: 0 0 auto;
    }
    .thumb {
      width: 120px;
      height: auto;
      border-radius: 8px;
      object-fit: cover;
      display: block;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
    }
    .summary img {
      max-width: 100%;
      max-height: 320px;
      height: auto;
      width: auto;
      object-fit: contain;
      display: block;
      margin: 6px 0;
      border-radius: 8px;
    }
    .summary blockquote {
      position: relative;
      margin: 12px 0;
      padding: 12px 14px 12px 16px;
      color: #cbd5e1;
      border: 1px solid rgba(125, 211, 252, 0.26);
      border-left-width: 4px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.7);
      box-shadow: 0 14px 32px rgba(0, 0, 0, 0.24);
    }
    .summary blockquote.quote-with-avatar {
      padding-left: 60px;
    }
    .summary blockquote.quote-clickable {
      cursor: pointer;
    }
    .summary blockquote.quote-with-avatar::after {
      content: "";
      position: absolute;
      top: 8px;
      left: 12px;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      background: #0f172a;
      background-image: var(--quote-avatar);
      background-size: cover;
      background-position: center;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
    }
    .summary hr {
      border: none;
      border-top: 1px solid rgba(148, 163, 184, 0.35);
      margin: 8px 0;
    }
    .summary video {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 6px 0;
      border-radius: 8px;
      background: #0f172a;
    }
    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.78);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      z-index: 9999;
    }
    .lightbox img {
      max-width: min(1200px, 94vw);
      max-height: 94vh;
      border-radius: 12px;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: #0f172a;
    }
    .lightbox.hidden {
      display: none;
    }
    .lightbox .lightbox-close {
      position: absolute;
      top: 14px;
      right: 14px;
      width: 38px;
      height: 38px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.25);
      color: #e2e8f0;
      font-size: 20px;
      font-weight: 700;
      display: grid;
      place-items: center;
      cursor: pointer;
    }
    .delete {
      border: none;
      background: transparent;
      color: #fca5a5;
      cursor: pointer;
      font-size: 20px;
      line-height: 1;
      padding: 4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 120ms ease, color 120ms ease;
    }
    .delete:hover { transform: translateY(-1px); color: #fecdd3; }
    .delete:active { transform: translateY(0); }
    .feed-actions {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .folder-btn {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      background: rgba(148, 163, 184, 0.12);
      color: #e2e8f0;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform 120ms ease, border-color 120ms ease;
    }
    .folder-btn:hover { transform: translateY(-1px); border-color: rgba(148, 163, 184, 0.6); }
    .folder-btn:active { transform: translateY(0); }
    .mark {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(125, 211, 252, 0.3);
      background: rgba(125, 211, 252, 0.08);
      color: #7dd3fc;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      transition: transform 120ms ease, border-color 120ms ease;
    }
    .mark:hover { transform: translateY(-1px); border-color: rgba(125, 211, 252, 0.6); }
    .mark:disabled { opacity: 0.6; cursor: default; transform: none; }
    .bookmark-btn {
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      border: 1px solid rgba(125, 211, 252, 0.3);
      background: rgba(125, 211, 252, 0.08);
      color: #7dd3fc;
      cursor: pointer;
      font-weight: 700;
      font-size: 13px;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
    }
    .bookmark-btn:hover { transform: translateY(-1px); border-color: rgba(125, 211, 252, 0.6); }
    .bookmark-btn:disabled { opacity: 0.6; cursor: default; transform: none; }
    .bookmark-btn.bookmarked {
      background: rgba(125, 211, 252, 0.16);
      border-color: rgba(125, 211, 252, 0.9);
      color: #bae6fd;
    }
    .mark-box {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: #bae6fd;
      font-size: 13px;
      user-select: none;
    }
    .mark-toggle {
      border: 1px solid rgba(125, 211, 252, 0.25);
      background: rgba(125, 211, 252, 0.08);
      border-radius: 10px;
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: #7dd3fc;
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, background 120ms ease;
      overflow: visible;
    }
    .mark-toggle:hover { transform: translateY(-1px); border-color: rgba(125, 211, 252, 0.5); }
    .mark-toggle:active { transform: translateY(0); }
    .mark-toggle.viewed { color: #cbd5e1; background: rgba(148, 163, 184, 0.08); border-color: rgba(148, 163, 184, 0.3); }
    .mark-icon {
      width: 22px;
      height: 22px;
      display: block;
      transform: scale(4);
      transform-origin: center;
    }
    .bookmark-btn .mark-icon {
      width: 18px;
      height: 18px;
      transform: scale(6);
    }
    .pager {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 12px;
      font-size: 14px;
      color: #cbd5e1;
    }
    .pager button {
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 700;
      background: rgba(125, 211, 252, 0.12);
      color: #e2e8f0;
      border: 1px solid rgba(125, 211, 252, 0.25);
    }
    .pager button:disabled {
      opacity: 0.5;
      cursor: default;
      transform: none;
    }
    .items-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin: 18px 0 8px;
    }
    .items-header h2 {
      margin: 0;
    }
    .items-header-controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #view-toggle,
    #sort-toggle,
    #range-toggle {
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid rgba(125, 211, 252, 0.3);
      background: rgba(125, 211, 252, 0.08);
      color: #7dd3fc;
      font-weight: 700;
      cursor: pointer;
    }
    .status {
      min-height: 20px;
      color: #a5f3fc;
      font-size: 14px;
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
    <div class="card">
      <h1>RSS Reader</h1>
      <div class="status" id="status"></div>
      <details class="collapsible">
        <summary>Manage feeds &amp; folders <span class="spoiler-arrow">▾</span></summary>
        <div class="collapsible-body">
          <form id="feed-form">
            <input id="feed-url" type="url" name="url" placeholder="https://example.com/feed.xml" required />
            <select id="feed-folder" name="folder" aria-label="Folder">
              <option value="Default">Default</option>
            </select>
            <button type="submit">Add feed</button>
          </form>
          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <input id="new-folder" type="text" name="new-folder" placeholder="New folder name" style="flex:1 1 220px;" />
            <select id="new-folder-parent" style="min-width:160px;flex:0 0 auto;">
              <option value="">Parent (root)</option>
            </select>
            <button type="button" id="create-folder">Create folder</button>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <select id="move-folder-select" style="min-width:200px;flex:1 1 200px;">
              <option value="">Select folder</option>
            </select>
            <select id="move-folder-parent" style="min-width:160px;flex:0 0 auto;">
              <option value="">New parent (root)</option>
            </select>
            <button type="button" id="move-folder">Move folder</button>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <select id="delete-folder-select" style="min-width:200px;flex:1 1 200px;">
              <option value="">Delete folder</option>
            </select>
            <button type="button" id="delete-folder">Delete folder</button>
          </div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;">
            <label style="display:flex;align-items:center;gap:8px;font-size:14px;color:#cbd5e1;">
              <input id="opml-file" type="file" accept=".opml, text/xml" style="color:#cbd5e1;" />
            </label>
            <button type="button" id="import-opml">Import OPML</button>
            <button type="button" id="export-opml">Export OPML</button>
          </div>
        </div>
      </details>
      <div id="feeds-block" class="feeds-block">
        <button id="feeds-toggle" class="spoiler-btn" aria-expanded="false">
          <span>Feed URLs <span id="feed-summary-label">(0)</span></span>
          <span class="spoiler-arrow">▾</span>
        </button>
        <div id="feeds-panel" class="feeds-panel hidden">
          <ul id="feeds" class="list"></ul>
        </div>
      </div>
      <div style="display:flex;flex-direction:column;gap:10px;margin:12px 0;">
        <label for="folder-filter" style="display:flex;align-items:center;gap:8px;font-size:14px;color:#cbd5e1;">
          Folder:
          <select id="folder-filter" style="min-width:170px;flex:0 0 auto;">
            <option value="">All folders</option>
          </select>
        </label>
      </div>
      <label for="item-limit" style="display:flex;align-items:center;gap:8px;margin-bottom:10px;font-size:14px;color:#cbd5e1;">
        Items to show (0 = all):
        <input id="item-limit" type="number" min="0" value="50" style="width:90px;padding:6px 8px;border-radius:8px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,23,42,0.8);color:var(--fg);" />
      </label>
      <div style="display:flex;align-items:center;gap:10px;margin:6px 0 12px;">
        <button type="button" id="refresh-feeds">Refresh feeds</button>
        <span id="last-refreshed" style="font-size:13px;color:#cbd5e1;">Last refreshed: —</span>
      </div>
      <div class="items-header">
        <h2>Items</h2>
        <div class="items-header-controls">
          <button type="button" id="view-toggle">View: Unviewed</button>
          <button type="button" id="range-toggle">Range: All time</button>
          <button type="button" id="sort-toggle">Sort: Most recent</button>
          <div class="pager pager-inline" style="display:none;">
            <button class="prev-page" type="button">Previous</button>
            <div class="page-info">Page 1</div>
            <button class="next-page" type="button">Next</button>
          </div>
        </div>
      </div>
      <ul id="items" class="list"></ul>
      <div class="pager pager-bottom" style="display:none;">
        <button class="prev-page" type="button">Previous</button>
        <div class="page-info">Page 1</div>
        <button class="next-page" type="button">Next</button>
      </div>
    </div>
  <script>
    const feedList = document.getElementById("feeds");
    const itemsList = document.getElementById("items");
    const statusBox = document.getElementById("status");
    const feedSummaryLabel = document.getElementById("feed-summary-label");
    const feedsBlock = document.getElementById("feeds-block");
    const feedsToggle = document.getElementById("feeds-toggle");
    const feedsPanel = document.getElementById("feeds-panel");
    const lastRefreshedLabel = document.getElementById("last-refreshed");
    const rangeToggleBtn = document.getElementById("range-toggle");
    const sortToggleBtn = document.getElementById("sort-toggle");
    const urlInput = document.getElementById("feed-url");
    const feedFolderInput = document.getElementById("feed-folder");
    const opmlInput = document.getElementById("opml-file");
    const importOpmlBtn = document.getElementById("import-opml");
    const exportOpmlBtn = document.getElementById("export-opml");
    const refreshBtn = document.getElementById("refresh-feeds");
    const itemLimitInput = document.getElementById("item-limit");
    const viewToggleBtn = document.getElementById("view-toggle");
    const folderFilterSelect = document.getElementById("folder-filter");
    const newFolderInput = document.getElementById("new-folder");
    const newFolderParentSelect = document.getElementById("new-folder-parent");
    const createFolderBtn = document.getElementById("create-folder");
    const moveFolderSelect = document.getElementById("move-folder-select");
    const moveFolderParentSelect = document.getElementById("move-folder-parent");
    const moveFolderBtn = document.getElementById("move-folder");
    const deleteFolderSelect = document.getElementById("delete-folder-select");
    const deleteFolderBtn = document.getElementById("delete-folder");
    const pagers = Array.from(document.querySelectorAll(".pager"));
    const pageInfos = Array.from(document.querySelectorAll(".page-info"));
    const prevPageBtns = Array.from(document.querySelectorAll(".prev-page"));
    const nextPageBtns = Array.from(document.querySelectorAll(".next-page"));
    const hashParams = () => new URLSearchParams((location.hash || "").replace(/^#/, ""));
    const initialParams = hashParams();
    const bookmarksKey = "__bookmarks__";
    const parsePositiveInt = (val, fallback) => {
      const n = parseInt(val, 10);
      return Number.isFinite(n) && n > 0 ? n : fallback;
    };
    let currentPage = parsePositiveInt(initialParams.get("page"), 1);
    const rangeOptions = ["all", "today", "week", "month"];
    const rangeLabels = { all: "All time", today: "Today", week: "Last week", month: "Last month" };
    const sortOptions = ["recent", "views", "likes"];
    const sortLabels = { recent: "Most recent", views: "Most views", likes: "Most likes" };
    const viewOptions = ["all", "viewed", "unviewed"];
    const viewLabels = { all: "All items", unviewed: "Unviewed only", viewed: "Viewed only" };
    const initialRange = (initialParams.get("range") || "all").toLowerCase();
    const initialSort = (initialParams.get("sort") || "recent").toLowerCase();
    const initialViewParam = (initialParams.get("view") || "").toLowerCase();
    const initialIncludeViewed = (initialParams.get("include_viewed") || "").toLowerCase();
    let currentRange = rangeOptions.includes(initialRange) ? initialRange : "all";
    let currentSort = sortOptions.includes(initialSort) ? initialSort : "recent";
    let currentView = viewOptions.includes(initialViewParam)
      ? initialViewParam
      : (["1", "true", "yes", "on"].includes(initialIncludeViewed) ? "all" : "unviewed");
    let totalItems = 0;
    let feedListCache = [];
    let feedFolders = {};
    let feedTitles = {};
    let itemCache = {};
    let lastRefreshAt = null;
    let pendingFolderFromHash = (initialParams.get("folder") || "").trim();
    let pendingAddFolderFromHash = (initialParams.get("add_folder") || "").trim();
    let appliedFolderFromHash = false;
    let appliedAddFolderFromHash = false;
    let suppressHashChange = false;
    const defaultFolder = "Default";
    let folders = new Set([defaultFolder]);
    feedFolderInput.value = defaultFolder;
    const initialLimit = parsePositiveInt(initialParams.get("limit"), null);
    if (initialLimit !== null && itemLimitInput) {
      itemLimitInput.value = initialLimit;
    }
    if (feedsToggle) {
      feedsToggle.addEventListener("click", (ev) => {
        ev.preventDefault();
        const open = feedsToggle.getAttribute("aria-expanded") === "true";
        setFeedsOpen(!open);
      });
    }
    const esc = (text = "") =>
      text.replace(/[&<>"']/g, (ch) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[ch]));
    const safeUrl = (url = "") =>
      (typeof url === "string" && (url.startsWith("http://") || url.startsWith("https://"))) ? url : "";
    const feedLabel = (url = "") => {
      const label = feedTitles[url];
      return typeof label === "string" && label.trim() ? label : url;
    };
    const formatAgo = (ms) => {
      const sec = Math.max(0, Math.floor(ms / 1000));
      if (sec < 60) return `${sec}s ago`;
      const min = Math.floor(sec / 60);
      if (min < 60) return `${min}m ago`;
      const hr = Math.floor(min / 60);
      if (hr < 24) return `${hr}h ago`;
      const day = Math.floor(hr / 24);
      return `${day}d ago`;
    };
    const renderLastRefreshed = () => {
      if (!lastRefreshedLabel) return;
      if (!lastRefreshAt) {
        lastRefreshedLabel.textContent = "Last refreshed: —";
        return;
      }
      const opts = { dateStyle: "short", timeStyle: "short" };
      const ago = formatAgo(Date.now() - lastRefreshAt.getTime());
      lastRefreshedLabel.textContent = `Last refreshed: ${lastRefreshAt.toLocaleString(undefined, opts)} (${ago})`;
    };
    const updateLastRefreshed = (value) => {
      if (!value) {
        lastRefreshAt = null;
      } else if (value instanceof Date) {
        lastRefreshAt = value;
      } else {
        const parsed = new Date(value);
        lastRefreshAt = Number.isNaN(parsed.getTime()) ? null : parsed;
      }
      renderLastRefreshed();
    };
    renderLastRefreshed();
    setInterval(renderLastRefreshed, 30000);
    const renderViewLabel = () => {
      if (!viewToggleBtn) return;
      const label = viewLabels[currentView] || viewLabels.unviewed;
      viewToggleBtn.textContent = `View: ${label}`;
    };
    renderViewLabel();
    const renderRangeLabel = () => {
      if (!rangeToggleBtn) return;
      const label = rangeLabels[currentRange] || rangeLabels.all;
      rangeToggleBtn.textContent = `Range: ${label}`;
    };
    renderRangeLabel();
    const renderSortLabel = () => {
      if (!sortToggleBtn) return;
      const label = sortLabels[currentSort] || sortLabels.recent;
      sortToggleBtn.textContent = `Sort: ${label}`;
    };
    renderSortLabel();
    const setFeedsOpen = (isOpen) => {
      if (!feedsToggle || !feedsPanel) return;
      feedsToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
      feedsPanel.classList.toggle("hidden", !isOpen);
      if (feedsBlock) {
        feedsBlock.classList.toggle("open", isOpen);
      }
    };
    const lightbox = document.createElement("div");
    lightbox.className = "lightbox hidden";
    lightbox.innerHTML = `<button class="lightbox-close" type="button" aria-label="Close image">&times;</button><img src="" alt="" />`;
    document.body.appendChild(lightbox);
    const lightboxImg = lightbox.querySelector("img");
    const closeLightbox = () => {
      lightbox.classList.add("hidden");
      lightboxImg.removeAttribute("src");
      lightboxImg.alt = "";
      document.body.style.overflow = "";
    };
    const openLightbox = (src, alt = "") => {
      if (!src) return;
      lightboxImg.src = src;
      lightboxImg.alt = alt;
      lightbox.classList.remove("hidden");
      document.body.style.overflow = "hidden";
    };
    lightbox.addEventListener("click", (ev) => {
      if (ev.target === lightbox || ev.target.classList.contains("lightbox-close")) {
        closeLightbox();
      }
    });
    window.addEventListener("keydown", (ev) => {
      if (ev.key === "Escape" && !lightbox.classList.contains("hidden")) {
        closeLightbox();
      }
    });
    const updateHash = () => {
      const params = new URLSearchParams();
      const folder = folderFilterSelect.value || "";
      const limit = parseInt(itemLimitInput.value, 10);
      const addFolder = (feedFolderInput.value || "").trim();
      const view = currentView || "unviewed";
      params.set("sort", currentSort || "recent");
      params.set("range", currentRange || "all");
      params.set("view", view);
      if (folder) params.set("folder", folder);
      if (addFolder) params.set("add_folder", addFolder);
      if (view === "all" || view === "viewed") params.set("include_viewed", "1");
      if (Number.isFinite(limit) && limit > 0) params.set("limit", limit);
      if (currentPage > 1) params.set("page", currentPage);
      const nextHash = params.toString();
      const target = nextHash ? `#${nextHash}` : "";
      if (location.hash === target) return;
      suppressHashChange = true;
      location.hash = target;
      setTimeout(() => { suppressHashChange = false; }, 0);
    };
    const viewedIcon = `<svg class="mark-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M1.606 6.08a1 1 0 0 1 1.313.526L2 7l.92-.394v-.001l.003.009l.021.045l.094.194c.086.172.219.424.4.729a13.4 13.4 0 0 0 1.67 2.237a12 12 0 0 0 .59.592C7.18 11.8 9.251 13 12 13a8.7 8.7 0 0 0 3.22-.602c1.227-.483 2.254-1.21 3.096-1.998a13 13 0 0 0 2.733-3.725l.027-.058l.005-.011a1 1 0 0 1 1.838.788L22 7l.92.394l-.003.005l-.004.008l-.011.026l-.04.087a14 14 0 0 1-.741 1.348a15.4 15.4 0 0 1-1.711 2.256l.797.797a1 1 0 0 1-1.414 1.415l-.84-.84a12 12 0 0 1-1.897 1.256l.782 1.202a1 1 0 1 1-1.676 1.091l-.986-1.514c-.679.208-1.404.355-2.176.424V16.5a1 1 0 0 1-2 0v-1.544c-.775-.07-1.5-.217-2.177-.425l-.985 1.514a1 1 0 0 1-1.676-1.09l.782-1.203c-.7-.37-1.332-.8-1.897-1.257l-.84.84a1 1 0 0 1-1.414-1.414l.797-.797a15.4 15.4 0 0 1-1.87-2.519a14 14 0 0 1-.591-1.107l-.033-.072l-.01-.021l-.002-.007l-.001-.002v-.001C1.08 7.395 1.08 7.394 2 7l-.919.395a1 1 0 0 1 .525-1.314" clip-rule="evenodd"/></svg>`;
    const unviewedIcon = `<svg class="mark-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M3.275 15.296C2.425 14.192 2 13.639 2 12c0-1.64.425-2.191 1.275-3.296C4.972 6.5 7.818 4 12 4s7.028 2.5 8.725 4.704C21.575 9.81 22 10.361 22 12c0 1.64-.425 2.191-1.275 3.296C19.028 17.5 16.182 20 12 20s-7.028-2.5-8.725-4.704Z"/><path d="M15 12a3 3 0 1 1-6 0a3 3 0 0 1 6 0Z"/></g></svg>`;
    const bookmarkIcon = `<svg class="mark-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-width="1.03" d="M16 14.046v-2.497c0-2.145 0-3.217-.586-3.883S13.886 7 12 7s-2.828 0-3.414.666S8 9.404 8 11.55v2.497c0 1.548 0 2.322.326 2.66a.95.95 0 0 0 .562.29c.438.056.95-.453 1.975-1.473c.453-.45.68-.676.942-.735a.9.9 0 0 1 .39 0c.262.059.489.284.942.735c1.024 1.02 1.537 1.53 1.976 1.473a.95.95 0 0 0 .56-.29c.327-.338.327-1.112.327-2.66Z"/></svg>`;
    const bookmarkedIcon = `<svg class="mark-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" stroke="currentColor" stroke-width="1.03" d="M16 14.046v-2.497c0-2.145 0-3.217-.586-3.883S13.886 7 12 7s-2.828 0-3.414.666S8 9.404 8 11.55v2.497c0 1.548 0 2.322.326 2.66a.95.95 0 0 0 .562.29c.438.056.95-.453 1.975-1.473c.453-.45.68-.676.942-.735a.9.9 0 0 1 .39 0c.262.059.489.284.942.735c1.024 1.02 1.537 1.53 1.976 1.473a.95.95 0 0 0 .56-.29c.327-.338.327-1.112.327-2.66Z"/></svg>`;
    const syncFolderSelects = () => {
      const filterCurrent = folderFilterSelect.value;
      const parentCurrent = newFolderParentSelect.value;
      const moveCurrent = moveFolderSelect.value;
      const moveParentCurrent = moveFolderParentSelect.value;
      const deleteCurrent = deleteFolderSelect.value;
      const addCurrent = feedFolderInput.value;
      const values = Array.from(new Set([defaultFolder, ...folders]));
      values.sort((a, b) => a.localeCompare(b));
      const optionList = values.map((f) => `<option value="${esc(f)}">${esc(f)}</option>`).join("");
      const folderOptions = `<option value="">All folders</option>${optionList}<option value="${bookmarksKey}">Bookmarks</option>`;
      folderFilterSelect.innerHTML = folderOptions;
      if (filterCurrent === bookmarksKey) {
        folderFilterSelect.value = bookmarksKey;
      } else {
        folderFilterSelect.value = values.includes(filterCurrent) ? filterCurrent : "";
      }
      const parentOptions = `<option value="">Parent (root)</option>${optionList}`;
      newFolderParentSelect.innerHTML = parentOptions;
      moveFolderParentSelect.innerHTML = parentOptions.replace("Parent (root)", "New parent (root)");
      feedFolderInput.innerHTML = optionList;
      const preferredAdd = (!appliedAddFolderFromHash && pendingAddFolderFromHash) ? pendingAddFolderFromHash : addCurrent;
      feedFolderInput.value = values.includes(preferredAdd) ? preferredAdd : defaultFolder;
      if (!appliedAddFolderFromHash && pendingAddFolderFromHash && values.includes(pendingAddFolderFromHash)) {
        appliedAddFolderFromHash = true;
      }
      if (!values.includes(parentCurrent)) {
        newFolderParentSelect.value = "";
      } else {
        newFolderParentSelect.value = parentCurrent;
      }
      moveFolderSelect.innerHTML = `<option value="">Select folder</option>${optionList}`;
      moveFolderSelect.value = values.includes(moveCurrent) ? moveCurrent : "";
      if (!values.includes(moveParentCurrent)) {
        moveFolderParentSelect.value = "";
      } else {
        moveFolderParentSelect.value = moveParentCurrent;
      }
      const deletable = values.filter((f) => f !== defaultFolder);
      const deleteOptions = deletable.map((f) => `<option value="${esc(f)}">${esc(f)}</option>`).join("");
      deleteFolderSelect.innerHTML = `<option value="">Delete folder</option>${deleteOptions}`;
      deleteFolderSelect.value = deletable.includes(deleteCurrent) ? deleteCurrent : "";
    };

    const renderFeeds = (feeds) => {
      const filter = folderFilterSelect.value || "";
      const isBookmarksFilter = filter === bookmarksKey;
      const filtered = filter && !isBookmarksFilter
        ? feeds.filter((url) => {
            const folders = Array.isArray(feedFolders[url]) && feedFolders[url].length
              ? feedFolders[url]
              : [defaultFolder];
            return folders.some((folder) => folder === filter || folder.startsWith(`${filter}/`));
          })
        : feeds;
      if (feedSummaryLabel) {
        feedSummaryLabel.textContent = `(${filtered.length})`;
      }
      const folderOptions = (current) => {
        const opts = Array.from(new Set([defaultFolder, ...folders, current || defaultFolder]));
        opts.sort((a, b) => a.localeCompare(b));
        return opts.map((f) => `<option value="${esc(f)}"${f === current ? " selected" : ""}>${esc(f)}</option>`).join("");
      };
      feedList.innerHTML = filtered.map((url) => {
        const foldersForFeed = Array.isArray(feedFolders[url]) && feedFolders[url].length
          ? feedFolders[url]
          : [defaultFolder];
        const primaryFolder = foldersForFeed[0];
        const folderLabel = foldersForFeed.map(esc).join(", ");
        const safe = esc(url);
        const label = esc(feedLabel(url));
        return `<li>
          <div class="feed-info">
            <span>${label}</span>
            <div class="feed-url">${safe}</div>
            <div class="folder-label">Folders: ${folderLabel}</div>
          </div>
          <div class="feed-actions">
            <select class="folder-select" data-url="${safe}" data-current="${esc(primaryFolder)}" aria-label="Move ${safe}">
              ${folderOptions(primaryFolder)}
            </select>
            <button class="delete" data-url="${safe}" aria-label="Remove ${safe}">&minus;</button>
          </div>
        </li>`;
      }).join("");
    };

    const applyFeeds = (data = {}) => {
      const feeds = Array.isArray(data.feeds) ? data.feeds : [];
      const incomingFolders = data.feed_folders && typeof data.feed_folders === "object" ? data.feed_folders : {};
      const incomingTitles = data.feed_titles && typeof data.feed_titles === "object" ? data.feed_titles : {};
      const mergedTitles = { ...feedTitles, ...incomingTitles };
      feedTitles = feeds.reduce((acc, url) => {
        const title = mergedTitles[url];
        if (typeof title === "string" && title.trim()) acc[url] = title;
        return acc;
      }, {});
      if (feedSummaryLabel) {
        feedSummaryLabel.textContent = `(${feeds.length})`;
      }
      feedListCache = feeds;
      feedFolders = {};
      feeds.forEach((url) => {
        const raw = incomingFolders[url];
        const list = Array.isArray(raw)
          ? raw.map((v) => (typeof v === "string" ? v.trim() : "")).filter(Boolean)
          : typeof raw === "string" && raw.trim() ? [raw.trim()] : [];
        const unique = Array.from(new Set(list));
        unique.sort((a, b) => a.localeCompare(b));
        feedFolders[url] = unique.length ? unique : [defaultFolder];
      });
      const allFolders = new Set([defaultFolder, ...(Array.isArray(data.folders) ? data.folders : [])]);
      Object.values(feedFolders).forEach((arr) => {
        (Array.isArray(arr) ? arr : []).forEach((name) => {
          if (typeof name === "string" && name.trim()) allFolders.add(name);
        });
      });
      folders = allFolders;
      syncFolderSelects();
      if (!appliedFolderFromHash && pendingFolderFromHash) {
        const hasFolder = Array.from(folderFilterSelect.options).some((opt) => opt.value === pendingFolderFromHash);
        folderFilterSelect.value = hasFolder ? pendingFolderFromHash : "";
        appliedFolderFromHash = true;
      }
      if (!appliedAddFolderFromHash && pendingAddFolderFromHash) {
        const hasAddFolder = Array.from(feedFolderInput.options || []).some((opt) => opt.value === pendingAddFolderFromHash);
        feedFolderInput.value = hasAddFolder ? pendingAddFolderFromHash : feedFolderInput.value;
        appliedAddFolderFromHash = true;
      }
      renderFeeds(feeds);
    };

    const formatTime = (value) => {
      if (!value) return "";
      const parsed = new Date(value);
      return Number.isNaN(parsed.getTime())
        ? value
        : parsed.toLocaleString(undefined, { dateStyle: "medium", timeStyle: "short" });
    };

    const sanitizeSummary = (html = "") => {
      const allowed = new Set(["a", "p", "br", "strong", "em", "b", "i", "u", "ul", "ol", "li", "pre", "code", "span", "div", "img", "video", "source", "blockquote", "hr"]);
      const drop = new Set(["footer", "cite"]);
      const attrAllow = {
        a: ["href", "title"],
        img: ["src", "alt", "title"],
        video: ["src", "poster", "controls", "autoplay", "loop", "muted", "playsinline"],
        source: ["src", "type"],
      };
      const safeUrl = (url = "") => (url.startsWith("http://") || url.startsWith("https://")) ? url : "";
      const isWhitespaceNode = (node) => node && node.nodeType === Node.TEXT_NODE && (node.textContent || "").trim() === "";
      const isDashTextNode = (node) => {
        if (!node || node.nodeType !== Node.TEXT_NODE) return false;
        const text = (node.textContent || "").trim();
        return text === "—" || text === "-" || text === "–";
      };
      const isNitterStatusLink = (href = "") => {
        if (!href) return false;
        try {
          const url = new URL(href, location.href);
          const host = (url.hostname || "").toLowerCase();
          if (!host.includes("nitter")) return false;
          return (url.pathname || "").toLowerCase().includes("/status/");
        } catch {
          return false;
        }
      };
      const pruneNitterQuoteFooter = (blockquote) => {
        if (!blockquote) return;
        let cursor = blockquote.lastChild;
        const trailingWhitespace = [];
        while (cursor && isWhitespaceNode(cursor)) {
          trailingWhitespace.push(cursor);
          cursor = cursor.previousSibling;
        }
        if (!cursor) return;
        const last = cursor;
        cursor = last.previousSibling;
        const midWhitespace = [];
        while (cursor && isWhitespaceNode(cursor)) {
          midWhitespace.push(cursor);
          cursor = cursor.previousSibling;
        }
        const dashNode = cursor;
        const linkNode = last.nodeType === Node.ELEMENT_NODE && last.tagName.toLowerCase() === "a" && isNitterStatusLink(last.getAttribute("href") || "");
        if (linkNode && isDashTextNode(dashNode)) {
          blockquote.removeChild(last);
          blockquote.removeChild(dashNode);
          midWhitespace.forEach((n) => blockquote.removeChild(n));
          trailingWhitespace.forEach((n) => blockquote.removeChild(n));
          while (blockquote.lastChild && isWhitespaceNode(blockquote.lastChild)) {
            blockquote.removeChild(blockquote.lastChild);
          }
        }
      };
      const doc = new DOMParser().parseFromString(html, "text/html");
      const clean = (node) => {
        if (node.nodeType === Node.TEXT_NODE) return document.createTextNode(node.textContent || "");
        if (node.nodeType !== Node.ELEMENT_NODE) return null;
        const tag = node.tagName.toLowerCase();
        if (drop.has(tag)) {
          const frag = document.createDocumentFragment();
          node.childNodes.forEach((child) => {
            const cleaned = clean(child);
            if (cleaned) frag.appendChild(cleaned);
          });
          return frag;
        }
        if (!allowed.has(tag)) return document.createTextNode(node.textContent || "");
        const el = document.createElement(tag);
        (attrAllow[tag] || []).forEach((attr) => {
          const val = node.getAttribute(attr);
          if (!val) return;
          if (attr === "href" || attr === "src" || attr === "poster") {
            const safe = safeUrl(val);
            if (!safe) return;
            el.setAttribute(attr, safe);
          } else {
            el.setAttribute(attr, val);
          }
        });
        if (tag === "a" && el.getAttribute("href")) {
          el.setAttribute("rel", "noopener noreferrer");
          el.setAttribute("target", "_blank");
        }
        if (tag === "video" && !el.hasAttribute("controls")) {
          el.setAttribute("controls", "");
          el.setAttribute("preload", "metadata");
        }
        node.childNodes.forEach((child) => {
          const cleaned = clean(child);
          if (cleaned) el.appendChild(cleaned);
        });
        if (tag === "blockquote") {
          pruneNitterQuoteFooter(el);
        }
        return el;
      };
      const container = document.createElement("div");
      doc.body.childNodes.forEach((child) => {
        const cleaned = clean(child);
        if (cleaned) container.appendChild(cleaned);
      });
      const isEmptyParagraph = (el) => {
        if (!el || el.tagName.toLowerCase() !== "p") return false;
        const text = (el.textContent || "").replace(/\u00a0/g, " ").trim();
        const hasMedia = el.querySelector("img, video, source");
        const hasNonBreakChild = Array.from(el.children).some((child) => child.tagName.toLowerCase() !== "br");
        return !hasMedia && !hasNonBreakChild && text === "";
      };
      const trimTrailingEmptyParagraphs = (root) => {
        let cursor = root.lastElementChild;
        while (cursor && isEmptyParagraph(cursor)) {
          const prev = cursor.previousElementSibling;
          root.removeChild(cursor);
          cursor = prev;
        }
      };
      trimTrailingEmptyParagraphs(container);
      const stripParagraphs = (root) => {
        const paragraphs = Array.from(root.querySelectorAll("p"));
        paragraphs.forEach((p) => {
          const frag = document.createDocumentFragment();
          while (p.firstChild) frag.appendChild(p.firstChild);
          p.replaceWith(frag);
        });
      };
      stripParagraphs(container);
      const trimWhitespaceEdges = (node) => {
        if (!node) return;
        const isElement = node.nodeType === Node.ELEMENT_NODE;
        if (isElement) {
          const tag = node.tagName.toLowerCase();
          if (tag === "pre" || tag === "code") return;
        }
        while (node.firstChild && node.firstChild.nodeType === Node.TEXT_NODE && node.firstChild.textContent.trim() === "") {
          node.removeChild(node.firstChild);
        }
        while (node.lastChild && node.lastChild.nodeType === Node.TEXT_NODE && node.lastChild.textContent.trim() === "") {
          node.removeChild(node.lastChild);
        }
        Array.from(node.childNodes).forEach((child) => {
          if (child.nodeType === Node.ELEMENT_NODE) trimWhitespaceEdges(child);
        });
      };
      trimWhitespaceEdges(container);
      return container.innerHTML;
    };

    const applyQuoteAvatars = (root = document) => {
      if (!root) return;
      const blockquotes = root.querySelectorAll(".summary[data-quote-avatar] blockquote");
      blockquotes.forEach((blockquote) => {
        const summaryEl = blockquote.closest(".summary");
        const avatar = summaryEl && summaryEl.dataset ? summaryEl.dataset.quoteAvatar : "";
        const linkEl = blockquote.querySelector("a[href^='http']");
        const linkHref = linkEl ? linkEl.getAttribute("href") : "";
        if (!avatar) return;
        blockquote.classList.add("quote-with-avatar");
        blockquote.style.setProperty("--quote-avatar", `url("${avatar.replace(/"/g, '\\"')}")`);
        if (linkHref) {
          blockquote.classList.add("quote-clickable");
          blockquote.dataset.quoteLink = linkHref;
          blockquote.addEventListener("click", (ev) => {
            if (ev.target.closest("img")) return;
            if (ev.target.closest("a")) return;
            window.open(linkHref, "_blank", "noopener,noreferrer");
          });
        }
      });
    };

    const renderItems = (items) => {
      itemsList.innerHTML = (items || []).map((item) => {
        const titleText = String(item.title || "(untitled)");
        const retweetByRaw = typeof item.retweet_by === "string" ? item.retweet_by.trim() : "";
        const retweetByDisplay = retweetByRaw.startsWith("@") ? retweetByRaw.slice(1) : retweetByRaw;
        const retweetBy = retweetByDisplay;
        const retweetOriginalRaw = typeof item.retweet_original_author === "string" ? item.retweet_original_author.trim() : "";
        const retweetOriginal = retweetOriginalRaw ? (retweetOriginalRaw.startsWith("@") ? retweetOriginalRaw : `@${retweetOriginalRaw}`) : "";
        const retweetOriginalAvatar = safeUrl(item.retweet_original_avatar || "");
        const retweetByAvatar = safeUrl(item.retweet_by_avatar || "");
        const isRetweet = Boolean(retweetBy);
        const displayTitleText = isRetweet ? `${retweetBy || "Retweeted"} retweeted` : titleText;
        const title = esc(displayTitleText);
        const safeLink = esc(item.link || "");
        const link = item.link ? `<a href="${safeLink}" target="_blank" rel="noopener noreferrer">${title}</a>` : title;
        const retweetIcon = isRetweet
          ? `<span class="rt-icon" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M2 16.25a.75.75 0 0 0 0 1.5zm3.603 1.5a.75.75 0 0 0 0-1.5zm5.145-3.663l-.643-.386zm2.504-4.174l.643.386zM22 7l.53.53a.75.75 0 0 0 0-1.06zm-2.53 1.47a.75.75 0 0 0 1.06 1.06zm1.06-4a.75.75 0 1 0-1.06 1.06zm-5.31 2.92l-.369-.653zm-6.5 8.338a.75.75 0 1 0 1.024 1.096zM2 17.75h3.603v-1.5H2zm9.39-3.277l2.505-4.174l-1.286-.772l-2.504 4.174zm7.007-6.723H22v-1.5h-3.603zm3.073-1.28l-2 2l1.06 1.06l2-2zm1.06 0l-2-2l-1.06 1.06l2 2zm-8.635 3.829c.434-.724.734-1.22 1.006-1.589c.263-.355.468-.543.689-.668l-.739-1.305c-.467.264-.82.627-1.155 1.08c-.326.44-.668 1.011-1.087 1.71zm4.502-4.049c-.815 0-1.48 0-2.025.052c-.562.055-1.054.17-1.521.435l.739 1.305c.22-.125.487-.204.927-.247c.456-.044 1.036-.045 1.88-.045zm-8.292 7.451c-.677 1.128-1.02 1.686-1.385 2.027l1.024 1.096c.557-.52 1.02-1.306 1.647-2.351zM2 6.25a.75.75 0 0 0 0 1.5zM22 17l.53.53a.75.75 0 0 0 0-1.06zm-1.47-2.53a.75.75 0 1 0-1.06 1.06zm-1.06 4a.75.75 0 1 0 1.06 1.06zm-3.345-1.525l.144-.736zm-1.682-2.33a.75.75 0 1 0-1.286.77zm.025 1.391l.558-.501zm-6.593-8.95l.143-.737zm1.682 2.33a.75.75 0 0 0 1.286-.772zm-.025-1.393l-.558.502zM2 7.75h4.668v-1.5H2zm15.332 10H22v-1.5h-4.668zm5.198-1.28l-2-2l-1.06 1.06l2 2zm-1.06 0l-2 2l1.06 1.06l2-2zm-4.138-.22c-.645 0-.867-.003-1.063-.041l-.287 1.472c.372.072.765.069 1.35.069zm-4.175-.864c.3.502.5.84.754 1.122l1.115-1.003c-.134-.149-.25-.337-.583-.89zm3.112.823a2.25 2.25 0 0 1-1.243-.704l-1.115 1.003a3.75 3.75 0 0 0 2.071 1.173zM6.668 7.75c.645 0 .867.003 1.063.041l.287-1.472c-.372-.072-.765-.069-1.35-.069zm4.175.864c-.3-.502-.5-.84-.754-1.122L8.974 8.495c.134.149.25.337.583.89zm-3.112-.823c.48.094.916.34 1.243.704l1.115-1.003a3.75 3.75 0 0 0-2.071-1.173z"/></svg></span>`
          : "";
        const feedNameRaw = feedTitles[item.feed] || item.feed_title || item.feed;
        const feedName = typeof feedNameRaw === "string" ? feedNameRaw : "";
        const isYoutube = typeof item.feed === "string" && item.feed.includes("youtube.com/feeds/videos.xml");
        const blueskyAvatarUrl = safeUrl(item.bluesky_author_avatar || "");
        const feedAvatarUrl = !isYoutube ? safeUrl(item.feed_image || "") : "";
        const avatarUrl = isRetweet
          ? (retweetOriginalAvatar || retweetByAvatar || blueskyAvatarUrl || feedAvatarUrl)
          : (blueskyAvatarUrl || feedAvatarUrl);
        const isNitterFeed = typeof item.feed === "string" && item.feed.toLowerCase().includes("nitter");
        const hasQuoteBlock = isNitterFeed && typeof item.summary === "string" && item.summary.toLowerCase().includes("<blockquote");
        const quoteAvatarUrl = hasQuoteBlock ? safeUrl(item.quote_avatar || retweetOriginalAvatar) : "";
        const avatarAlt = esc(
          isRetweet
            ? (retweetOriginal || retweetBy || displayTitleText || "Retweeter")
            : (
              blueskyAvatarUrl
                ? (item.bluesky_author_display || item.bluesky_author_handle || displayTitleText || "Author")
                : (feedName || displayTitleText || "Feed")
            )
        );
        const avatar = avatarUrl
          ? `<img class="item-avatar" src="${esc(avatarUrl)}" alt="${avatarAlt}" loading="lazy" />`
          : "";
        const linkWithIcon = isRetweet ? `${retweetIcon}${link}` : link;
        const titleBlock = avatarUrl
          ? `<div class="item-title with-avatar">${avatar}${linkWithIcon}</div>`
          : `<div class="item-title">${linkWithIcon}</div>`;
        const thumbUrl = safeUrl(item.thumbnail || "");
        const thumbLinkOpen = item.link ? ` href="${safeLink}" target="_blank" rel="noopener noreferrer"` : "";
        const thumb = thumbUrl ? `<div class="thumb-wrap"><a${thumbLinkOpen}><img class="thumb" src="${esc(thumbUrl)}" alt="" loading="lazy" /></a></div>` : "";
        const showFeedName = feedName && feedName.trim().toLowerCase() !== displayTitleText.trim().toLowerCase();
        const blueskyHandleRaw = typeof item.bluesky_author_handle === "string" ? item.bluesky_author_handle.trim() : "";
        const blueskyHandle = blueskyHandleRaw ? (blueskyHandleRaw.startsWith("@") ? blueskyHandleRaw : `@${blueskyHandleRaw}`) : "";
        const metaLines = [];
        let youtubeViewsText = "";
        const youtubeViewsRaw = item.youtube_views;
        if (youtubeViewsRaw !== undefined && youtubeViewsRaw !== null) {
          const parsed = Number(youtubeViewsRaw);
          if (Number.isFinite(parsed)) youtubeViewsText = `${parsed.toLocaleString()} views`;
        }
        const published = formatTime(item.published);
        const standardMetaBits = [];
        if (blueskyHandle) standardMetaBits.push(esc(blueskyHandle));
        else if (!isRetweet && showFeedName) standardMetaBits.push(esc(feedName));
        if (!isRetweet && published) standardMetaBits.push(esc(published));
        if (standardMetaBits.length) metaLines.push(`<div class="meta">${standardMetaBits.join(" · ")}</div>`);
        if (isRetweet) {
          const originalPieces = [];
          if (retweetOriginal) originalPieces.push(esc(retweetOriginal));
          if (published) originalPieces.push(esc(published));
          const retweetLabel = originalPieces.join(" · ");
          if (retweetLabel) metaLines.push(`<div class="meta retweet-meta">${retweetLabel}</div>`);
        }
        const meta = metaLines.join("");
        const summaryParts = [];
        if (item.summary) {
          const summaryAttrs = [];
          if (quoteAvatarUrl) summaryAttrs.push(`data-quote-avatar="${esc(quoteAvatarUrl)}"`);
          const attrs = summaryAttrs.length ? ` ${summaryAttrs.join(" ")}` : "";
          summaryParts.push(`<div class="summary"${attrs}>${sanitizeSummary(item.summary)}</div>`);
        }
        if (youtubeViewsText) summaryParts.push(`<div class="summary">${esc(youtubeViewsText)}</div>`);
        const summary = summaryParts.join("");
        const viewed = Boolean(item.viewed);
        const bookmarked = item.bookmarked === true || item.bookmarked === "true";
        const bookmarkBtn = item.id
          ? `<button class="bookmark-btn${bookmarked ? " bookmarked" : ""}" data-id="${esc(item.id)}" data-bookmarked="${bookmarked ? "true" : "false"}" title="Bookmark entry">${bookmarked ? bookmarkedIcon : bookmarkIcon}</button>`
          : "";
        const markBtn = item.id
          ? `<button class="mark-toggle ${viewed ? "viewed" : ""}" data-id="${esc(item.id)}" data-viewed="${viewed ? "true" : "false"}" title="Toggle viewed">
                ${viewed ? viewedIcon : unviewedIcon}
              </button>`
          : "";
        const actions = item.id ? `<div class="item-actions">${bookmarkBtn}${markBtn}</div>` : "";
        const liClass = viewed ? "viewed" : "";
        return `<li class="${liClass}">
          <div class="item-head">
            ${thumb}
            <div class="item-main">
              ${titleBlock}
              ${meta}
            </div>
            ${actions}
          </div>
          ${summary}
        </li>`;
      }).join("");
      applyQuoteAvatars(itemsList);
    };

    const setStatus = (text, isError = false) => {
      statusBox.textContent = text || "";
      statusBox.style.color = isError ? "#fca5a5" : "#a5f3fc";
    };

    const fetchFeeds = () =>
      fetch("/api/feeds")
        .then((r) => r.json())
        .then((data) => {
          applyFeeds(data);
          updateLastRefreshed(data.last_refreshed);
        })
        .catch(() => setStatus("Failed to load feeds", true));

    const fetchItems = () => {
      const n = parseInt(itemLimitInput.value, 10);
      const limit = Number.isFinite(n) ? n : 30;
      const params = [];
      params.push(limit > 0 ? `limit=${limit}` : "limit=0");
      if (limit > 0) params.push(`page=${currentPage}`);
      const viewParam = currentView || "unviewed";
      params.push(`view=${encodeURIComponent(viewParam)}`);
      if (viewParam === "all" || viewParam === "viewed") params.push("include_viewed=1");
      params.push(`sort=${encodeURIComponent(currentSort || "recent")}`);
      params.push(`range=${encodeURIComponent(currentRange || "all")}`);
      if (folderFilterSelect.value) params.push(`folder=${encodeURIComponent(folderFilterSelect.value)}`);
      const qs = params.length ? `?${params.join("&")}` : "";
      return fetch(`/api/items${qs}`)
        .then((r) => r.json())
        .then((data) => {
          const items = Array.isArray(data.items) ? data.items : [];
          const incomingTitles = data.feed_titles && typeof data.feed_titles === "object" ? data.feed_titles : {};
          if (typeof data.view === "string") {
            const returnedView = data.view.toLowerCase();
            if (viewOptions.includes(returnedView) && returnedView !== currentView) {
              currentView = returnedView;
              renderViewLabel();
            }
          }
          if (typeof data.sort === "string") {
            const returnedSort = data.sort.toLowerCase();
            if (sortOptions.includes(returnedSort) && returnedSort !== currentSort) {
              currentSort = returnedSort;
              renderSortLabel();
            }
          }
          if (typeof data.range === "string") {
            const returnedRange = data.range.toLowerCase();
            if (rangeOptions.includes(returnedRange) && returnedRange !== currentRange) {
              currentRange = returnedRange;
              renderRangeLabel();
            }
          }
          let titlesChanged = false;
          const nextTitles = { ...feedTitles };
          Object.entries(incomingTitles).forEach(([url, title]) => {
            if (typeof url !== "string" || typeof title !== "string") return;
            const clean = title.trim();
            if (!clean) return;
            if (nextTitles[url] !== clean) titlesChanged = true;
            nextTitles[url] = clean;
          });
          items.forEach((item) => {
            const url = typeof item.feed === "string" ? item.feed : "";
            const title = typeof item.feed_title === "string" ? item.feed_title : "";
            const clean = title.trim();
            if (!url || !clean) return;
            if (nextTitles[url] !== clean) titlesChanged = true;
            nextTitles[url] = clean;
          });
          feedTitles = nextTitles;
          if (titlesChanged && feedListCache.length) {
            renderFeeds(feedListCache);
          }
          totalItems = data.total || items.length;
          const pageFromServer = data.page || 1;
          const maxPage = limit > 0 ? Math.max(1, Math.ceil((totalItems || 0) / limit)) : 1;
          if (pageFromServer > maxPage) {
            currentPage = maxPage;
            return fetchItems();
          }
          currentPage = pageFromServer;
          updateHash();
          itemCache = {};
          items.forEach((item) => {
            if (item && item.id) itemCache[item.id] = item;
          });
          renderItems(items);
          updatePager(maxPage);
          updateLastRefreshed(data.last_refreshed);
        })
        .catch(() => setStatus("Failed to load items", true));
    };

    document.getElementById("feed-form").addEventListener("submit", (ev) => {
      ev.preventDefault();
      const url = urlInput.value.trim();
      const folder = (feedFolderInput.value || "").trim() || defaultFolder;
      if (!url) return;
      setStatus("Adding feed...");
      fetch("/api/feeds", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url, folder }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          setStatus(data.message || "Added");
          urlInput.value = "";
        })
        .catch((err) => setStatus(err.message || "Failed to add feed", true));
    });

    importOpmlBtn.addEventListener("click", () => {
      const file = (opmlInput.files || [])[0];
      if (!file) {
        setStatus("Choose an OPML file first", true);
        return;
      }
      const form = new FormData();
      form.append("file", file);
      setStatus("Importing OPML...");
      fetch("/api/feeds/import", { method: "POST", body: form })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          setStatus(data.message || "Imported");
          fetchItems();
        })
        .catch((err) => setStatus(err.message || "Failed to import", true));
    });

    exportOpmlBtn.addEventListener("click", () => {
      setStatus("Exporting OPML...");
      fetch("/api/feeds/export")
        .then((r) => {
          if (!r.ok) throw new Error("Failed");
          return r.blob();
        })
        .then((blob) => {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "feeds.opml";
          a.click();
          URL.revokeObjectURL(url);
          setStatus("Exported");
        })
        .catch((err) => setStatus(err.message || "Failed to export", true));
    });

    refreshBtn.addEventListener("click", () => {
      setStatus("Refreshing feeds...");
      refreshBtn.disabled = true;
      fetch("/api/feeds/refresh", { method: "POST" })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          setStatus(data.message || "Refreshed");
          currentPage = 1;
          return fetchItems();
        })
        .catch((err) => setStatus(err.message || "Failed to refresh", true))
        .finally(() => {
          refreshBtn.disabled = false;
        });
    });

    createFolderBtn.addEventListener("click", () => {
      const name = (newFolderInput.value || "").trim();
      const parent = (newFolderParentSelect.value || "").trim();
      if (!name) {
        setStatus("Folder name required", true);
        return;
      }
      createFolderBtn.disabled = true;
      setStatus("Creating folder...");
      fetch("/api/folders", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name, parent }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          newFolderInput.value = "";
          newFolderParentSelect.value = parent || "";
          setStatus(data.message || "Folder created");
        })
        .catch((err) => setStatus(err.message || "Failed to create folder", true))
        .finally(() => {
          createFolderBtn.disabled = false;
        });
    });

    moveFolderBtn.addEventListener("click", () => {
      const folder = (moveFolderSelect.value || "").trim();
      const parent = (moveFolderParentSelect.value || "").trim();
      if (!folder) {
        setStatus("Choose a folder to move", true);
        return;
      }
      moveFolderBtn.disabled = true;
      setStatus("Moving folder...");
      fetch("/api/folders/move", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ folder, parent }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          moveFolderParentSelect.value = parent || "";
          setStatus(data.message || "Folder moved");
        })
        .catch((err) => setStatus(err.message || "Failed to move folder", true))
        .finally(() => {
          moveFolderBtn.disabled = false;
        });
    });

    deleteFolderBtn.addEventListener("click", () => {
      const folder = (deleteFolderSelect.value || "").trim();
      if (!folder || folder === defaultFolder) {
        setStatus("Choose a folder to delete", true);
        return;
      }
      deleteFolderBtn.disabled = true;
      setStatus("Deleting folder...");
      fetch("/api/folders", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ folder }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          deleteFolderSelect.value = "";
          currentPage = 1;
          setStatus(data.message || "Folder deleted");
          return fetchItems();
        })
        .catch((err) => setStatus(err.message || "Failed to delete folder", true))
        .finally(() => {
          deleteFolderBtn.disabled = false;
        });
    });

    moveFolderSelect.addEventListener("change", () => {
      moveFolderParentSelect.value = "";
    });

    feedList.addEventListener("change", (ev) => {
      const select = ev.target.closest("select.folder-select");
      if (!select) return;
      const url = select.dataset.url;
      if (!url) return;
      const previous = select.dataset.current || defaultFolder;
      const folder = (select.value || "").trim() || defaultFolder;
      select.disabled = true;
      setStatus("Moving feed...");
      fetch("/api/feeds/folder", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url, folder }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          setStatus(data.message || "Moved");
          currentPage = 1;
          return fetchItems();
        })
        .catch((err) => {
          select.disabled = false;
          select.value = previous;
          setStatus(err.message || "Failed to move feed", true);
        });
    });

    feedList.addEventListener("click", (ev) => {
      const btn = ev.target.closest("button.delete");
      if (!btn) return;
      const url = btn.dataset.url;
      setStatus("Removing feed...");
      fetch("/api/feeds", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ url }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          applyFeeds(data);
          setStatus(data.message || "Removed");
          fetchItems();
        })
        .catch((err) => setStatus(err.message || "Failed to remove feed", true));
    });

    itemLimitInput.addEventListener("change", () => {
      currentPage = 1;
      updateHash();
      fetchItems();
    });
    folderFilterSelect.addEventListener("change", () => {
      currentPage = 1;
      renderFeeds(feedListCache);
      updateHash();
      fetchItems();
    });
    prevPageBtns.forEach((btn) =>
      btn.addEventListener("click", () => {
        if (currentPage <= 1) return;
        currentPage -= 1;
        fetchItems();
      })
    );
    nextPageBtns.forEach((btn) =>
      btn.addEventListener("click", () => {
        const n = parseInt(itemLimitInput.value, 10);
        if (!(Number.isFinite(n) && n > 0)) return;
        const maxPage = Math.max(1, Math.ceil((totalItems || 0) / n));
        if (currentPage >= maxPage) return;
        currentPage += 1;
        fetchItems();
      })
    );

    const applyHashState = () => {
      if (suppressHashChange) return;
      const params = hashParams();
      const folder = (params.get("folder") || "").trim();
      const page = parsePositiveInt(params.get("page"), 1);
      const limit = parsePositiveInt(params.get("limit"), null);
      const addFolder = (params.get("add_folder") || "").trim();
      const includeViewed = (params.get("include_viewed") || "").toLowerCase();
      const viewParam = (params.get("view") || "").toLowerCase();
      const rangeParam = (params.get("range") || "").toLowerCase();
      const sortParam = (params.get("sort") || "").toLowerCase();
      currentRange = rangeOptions.includes(rangeParam) ? rangeParam : "all";
      currentSort = sortOptions.includes(sortParam) ? sortParam : "recent";
      const nextView = viewOptions.includes(viewParam)
        ? viewParam
        : (["1", "true", "yes", "on"].includes(includeViewed) ? "all" : "unviewed");
      currentView = nextView;
      renderRangeLabel();
      renderSortLabel();
      renderViewLabel();
      if (limit !== null) {
        itemLimitInput.value = limit;
      }
      pendingFolderFromHash = folder;
      pendingAddFolderFromHash = addFolder;
      appliedFolderFromHash = false;
      appliedAddFolderFromHash = false;
      currentPage = page;
      renderFeeds(feedListCache);
      fetchItems();
    };

    window.addEventListener("hashchange", applyHashState);
    feedFolderInput.addEventListener("change", () => {
      updateHash();
    });
    if (viewToggleBtn) {
      viewToggleBtn.addEventListener("click", () => {
        const idx = viewOptions.indexOf(currentView);
        const next = viewOptions[(idx + 1) % viewOptions.length];
        currentView = next;
        renderViewLabel();
        currentPage = 1;
        updateHash();
        fetchItems();
      });
    }
    if (rangeToggleBtn) {
      rangeToggleBtn.addEventListener("click", () => {
        const idx = rangeOptions.indexOf(currentRange);
        const next = rangeOptions[(idx + 1) % rangeOptions.length];
        currentRange = next;
        renderRangeLabel();
        currentPage = 1;
        updateHash();
        fetchItems();
      });
    }
    if (sortToggleBtn) {
      sortToggleBtn.addEventListener("click", () => {
        const idx = sortOptions.indexOf(currentSort);
        const next = sortOptions[(idx + 1) % sortOptions.length];
        currentSort = next;
        renderSortLabel();
        updateHash();
        fetchItems();
      });
    }

    itemsList.addEventListener("click", (ev) => {
      const img = ev.target.closest(".summary img");
      if (img) {
        const src = img.getAttribute("src") || "";
        if (src.startsWith("http://") || src.startsWith("https://")) {
          ev.preventDefault();
          openLightbox(src, img.getAttribute("alt") || "");
        }
        return;
      }
      const bookmarkBtn = ev.target.closest("button.bookmark-btn");
      if (bookmarkBtn) {
        const id = bookmarkBtn.dataset.id;
        const entry = id ? itemCache[id] : null;
        if (!id) return;
        const isBookmarked = bookmarkBtn.dataset.bookmarked === "true";
        if (!isBookmarked && !entry) return;
        bookmarkBtn.disabled = true;
        const method = isBookmarked ? "DELETE" : "POST";
        const body = isBookmarked ? { id } : { entry };
        const nextIcon = isBookmarked ? bookmarkIcon : bookmarkedIcon;
        setStatus(isBookmarked ? "Removing bookmark..." : "Saving bookmark...");
        fetch("/api/bookmarks", {
          method,
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        })
          .then((r) => r.json().then((data) => ({ status: r.status, data })))
          .then(({ status, data }) => {
            if (status >= 400) throw new Error(data.error || "Failed");
            setStatus(data.message || (isBookmarked ? "Unbookmarked" : "Bookmarked"));
            const nowBookmarked = !isBookmarked;
            bookmarkBtn.dataset.bookmarked = nowBookmarked ? "true" : "false";
            bookmarkBtn.classList.toggle("bookmarked", nowBookmarked);
            bookmarkBtn.innerHTML = nextIcon;
            bookmarkBtn.title = nowBookmarked ? "Bookmarked" : "Bookmark entry";
            if (!nowBookmarked && folderFilterSelect.value === bookmarksKey) {
              fetchItems();
            }
          })
          .catch((err) => setStatus(err.message || "Failed to bookmark", true))
          .finally(() => {
            bookmarkBtn.disabled = false;
          });
        return;
      }
      const btn = ev.target.closest("button.mark-toggle");
      if (!btn) return;
      const id = btn.dataset.id;
      if (!id) return;
      const nextViewed = btn.dataset.viewed === "true" ? false : true;
      btn.disabled = true;
      setStatus(nextViewed ? "Marking viewed..." : "Unmarking...");
      fetch("/api/items/viewed", {
        method: nextViewed ? "POST" : "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id }),
      })
        .then((r) => r.json().then((data) => ({ status: r.status, data })))
        .then(({ status, data }) => {
          if (status >= 400) throw new Error(data.error || "Failed");
          setStatus(data.message || (nextViewed ? "Marked" : "Unmarked"));
          fetchItems();
        })
        .catch((err) => {
          btn.disabled = false;
          setStatus(err.message || "Failed to update", true);
        });
    });

    const updatePager = (maxPage) => {
      const n = parseInt(itemLimitInput.value, 10);
      const limit = Number.isFinite(n) ? n : 30;
      const disablePaging = !Number.isFinite(limit) || limit <= 0 || totalItems <= limit;
      pagers.forEach((p) => {
        p.style.display = disablePaging ? "none" : "flex";
      });
      if (disablePaging) return;
      pageInfos.forEach((info) => {
        info.textContent = `Page ${currentPage} of ${maxPage}`;
      });
      prevPageBtns.forEach((btn) => {
        btn.disabled = currentPage <= 1;
      });
      nextPageBtns.forEach((btn) => {
        btn.disabled = currentPage >= maxPage;
      });
    };

    fetchFeeds().then(fetchItems).catch(fetchItems);
  </script>
</body>
</html>
